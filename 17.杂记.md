- [微架构是什么？](#微架构是什么)
- [DNS是什么？](#dns是什么)
- [关于频率和流水：](#关于频率和流水)
  - [1. 什么是频率（Frequency）？](#1-什么是频率frequency)
  - [2. 什么是“一级流水”（Pipeline Stage）？](#2-什么是一级流水pipeline-stage)
  - [3. 为什么“一级延迟”能换取“更快频率”？](#3-为什么一级延迟能换取更快频率)
    - [**场景 A：不加流水线（低频率）**](#场景-a不加流水线低频率)
    - [**场景 B：加了一级流水（高频率）**](#场景-b加了一级流水高频率)
- [关于打拍](#关于打拍)
  - [1. “打拍”是构建“流水线”的基石](#1-打拍是构建流水线的基石)
  - [2. 它们如何共同提升性能？](#2-它们如何共同提升性能)
  - [3. 香山代码中的具体体现](#3-香山代码中的具体体现)
  - [总结](#总结)


## 微架构是什么？

- 微架构是对指令集架构的具体实现：英特尔和 AMD 拥有不同的微架构，它们都用来实现 x86 这个 ISA，苹果公司为 iPhone 设计的 A 系列芯片，和高通为安卓设备设计的 骁龙芯片，它们都实现了 ARM ISA，但采用了完全不同的微架构。这也就是为什么尽管它们都运行 ARM 软件，性能和功耗却各有差异。

## DNS是什么？

（Domain Name System）域名系统

**核心功能：** 将人们容易记忆的**域名**（例如 `www.baidu.com` 或 `www.google.com`）翻译（或“解析”）成机器才能理解和使用的 **IP 地址**（例如 `14.215.177.38`）

**DNS 就是翻译官：** 当你在浏览器中输入一个域名时，你的电脑会向 DNS 服务器发起查询，DNS 服务器找到这个域名对应的 IP 地址，然后把 IP 地址告诉你，你的电脑才能真正连接到目标服务器

步骤：

- 用户发起请求： 你在浏览器中输入 example.com。

- 查询本地 DNS 解析器： 你的操作系统或路由器（本地 DNS 服务器，比如你配置文件中的 192.168.1.1）接收到请求。

- 解析器查找： 如果本地解析器没有缓存该域名的 IP 地址，它会递归地向全球的 DNS 系统查询（从根域名服务器开始，到顶级域名服务器，再到权威域名服务器）。

- 返回 IP 地址： 最终，权威服务器返回 example.com 对应的 IP 地址（比如 93.184.216.34）。

- 建立连接： 你的电脑使用这个 IP 地址，直接与目标网站的服务器建立连接，开始加载网页。



/etc/resolve.conf文件中我们配置：

```c
nameserver 8.8.8.8
nameserver 223.5.5.5
```

这些IP指向了公共且权威的、位于互联网上的 DNS 服务器

**8.8.8.8**：这是 **Google** 提供的公共 DNS 服务器。

**223.5.5.5**：这是 **阿里云** 提供的公共 DNS 服务器。

这些服务器是**专门用来处理全球互联网域名解析请求**的高性能、高可靠性服务器

当您的系统（客户端）向它们发送一个域名查询请求时，这些公共 DNS 服务器会负责完成整个递归查询（Recursive Query）过程：

- 客户端请求： 您的系统请求 8.8.8.8，询问 security.ubuntu.com 的 IP 地址。

- 根服务器查询： 8.8.8.8 会首先查询全球 根域名服务器（Root Servers），找到管理 .com 顶级域名的服务器。

- 顶级域查询： 接着，查询 .com 的 TLD（顶级域名）服务器，找到管理 ubuntu.com 的权威 DNS 服务器。

- 权威查询： 最后，查询 ubuntu.com 的 权威 DNS 服务器，获取到 security.ubuntu.com 对应的最终 IP 地址。

- 返回结果： 8.8.8.8 将这个 IP 地址返回给您的系统。



![image-20251110151318408](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20251110151318408.png)



## 关于频率和流水：

### 1. 什么是频率（Frequency）？

在 CPU 设计中，**频率**（通常以 GHz 为单位）就是**时钟（Clock）跳动的速度**。

- **时钟周期（Clock Cycle）**：想象一个节拍器，“嗒、嗒、嗒”地响。每响一声，就是一个周期。
- **频率的本质**：频率越高，每秒钟发生的“嗒”声就越多。如果频率是 3GHz，意味着 1 秒钟内节拍器跳动了 30 亿次。
- **硬件的约束**：在每一个“嗒”（周期）的时间里，电流必须跑完你安排的所有逻辑门（与、或、非门）。

------

### 2. 什么是“流水”（Pipeline Stage）？

“流水线”这个词源于工业生产。**二级流水**就是在电路路径中间加了一层**寄存器（Register）**，把任务截断。

- **一级流水线**：一个工人（电路）必须从头到尾完成一件复杂的工艺，才能领下一个活。
- **二级流水线**：我们在中间放一个桌子（寄存器）。工人 A 只负责做前半部分，做完放在桌上；工人 B 从桌上拿走半成品，负责做后半部分。

在你的代码中，`Pipeline(..., 1)` 里的这个 **“1”**，就是在这条路径中间放了一个“桌子”，把原本一长串的逻辑变成了前后两个阶段。



这里注意，

------

### 3. 为什么“一级延迟”能换取“更快频率”？

这是最关键的地方。**频率受限于“最慢的那条路”。**

#### **场景 A：不加流水线（低频率）**

假设从“预取算法计算”到“进入 L3 核心”总共有 **100 个逻辑门**。

- 电流跑完这 100 个门需要 **1 纳秒**。
- 为了让电路稳定，你的时钟周期**最快也只能是 1 纳秒**。
- 此时频率 = 1 / 1 纳秒 = **1 GHz**。

#### **场景 B：加了一级流水（高频率）**

我们在第 50 个逻辑门后面加了一级 `pipe`（寄存器）。

- 现在，电流在第一个周期只需要跑完 **50 个门**（到 `pipe` 停下），第二个周期再跑完剩下的 **50 个门**。
- 跑完 50 个门只需要 **0.5 纳秒**。
- 此时，你的时钟周期可以压缩到 **0.5 纳秒**！
- 此时频率 = 1 / 0.5 纳秒 = **2 GHz**。

**结论：**

- **延迟（Latency）增加了**：以前一个请求 1 纳秒（1 个周期）就能到，现在需要 0.5+0.5 纳秒（2 个周期）才能到。这就是你说的“一级的延迟”。
- **频率（Frequency）翻倍了**：整个芯片现在可以跑在 2 GHz 了。



## 关于打拍

“打拍”和“流水线”的关系可以总结为：**“打拍”是动作（手段），“流水线”是结构（结果）。**

我们可以通过以下三个层面来透彻理解它们之间的逻辑纽带：

------

### 1. “打拍”是构建“流水线”的基石

**打拍（Registering）**是指在电路中插入 D 触发器（寄存器）。

**流水线（Pipelining）**是指将一个复杂的任务拆分成多个阶段，每个阶段同时处理不同的任务。

如果没有“打拍”这个动作，信号就会像水流一样从头直流到尾，这就是**纯组合逻辑**。当你每“打一拍”，你就物理性地在逻辑通路上建立了一道“墙”（寄存器）。两道墙之间的一个区间，就构成了一个**流水线级（Pipeline Stage）**。

### 2. 它们如何共同提升性能？

这两个概念结合在一起，解决了硬件设计中的核心矛盾：**单次任务的快慢 vs. 单位时间的总产出。**

- **打拍减少了“每拍耗时”**：通过打拍把长路径切断，每一拍内电流需要跑的路程变短了。这意味着时钟周期可以缩短，**频率（Frequency）**也就提上去了。
- **流水线提升了“吞吐量”**：虽然打拍让单个请求从开始到结束的总时间（Latency）变长了，但因为有了流水线，每一拍都可以送入一个新请求。

**类比：洗车房**

- **打拍**：相当于在洗车房内部划分子任务——冲洗、打蜡、烘干。每道工序之间有挡板隔开。
- **流水线**：因为有了挡板（寄存器），你可以同时洗三辆车：第一辆在烘干，第二辆在打蜡，第三辆在冲洗。
- **关系**：没有“打拍”这个物理隔断，你一次只能洗一辆车，必须等整辆车洗完（延迟）才能进下一辆。有了打拍，虽然一辆车洗完的时间没变（甚至变长），但你**每分钟产出的洗好车辆（吞吐量）**翻了三倍。

### 3. 香山代码中的具体体现

回到你之前看的代码：

Scala

```
val pipe = Module(new Pipeline(io.req.bits.cloneType, 1))
pipe.io.in <> pftQueue.io.deq
io.req <> pipe.io.out
```

- **这里的动作是“打拍”**：`Pipeline(..., 1)` 内部通过寄存器对信号进行了一次锁存。
- **这里形成的是“二级流水”**：
  - **第一级（Stage 1）**：`pftQueue` 的出队逻辑（寻找谁该出队）。
  - **第二级（Stage 2）**：`pipe` 模块。它拿着上一拍选出的地址，稳稳地向 L3 核心发起请求。
- **结果**：即使 `pftQueue` 的选择逻辑很慢，它也不会拖累 L3 核心的步调，因为它们之间通过“打拍”隔开，形成了流水线。

------

### 总结

| **概念**   | **角色**     | **关注点**                                                |
| ---------- | ------------ | --------------------------------------------------------- |
| **打拍**   | **物理操作** | 插入寄存器，切断组合逻辑，优化时序（Timing）。            |
| **流水线** | **架构设计** | 任务并行化，提升主频（Frequency）和吞吐量（Throughput）。 |