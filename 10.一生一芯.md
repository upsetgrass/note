# 状态机模型

状态集合S = {$S_1$, $S_2$，...}

激励事件E

状态转移规则next：S×E->S  把一个状态和一个事件映射到另一个状态

​    描述每个状态在不同激励事件下的次态（next state）

初始状态$S_0\in S$

![image-20250212172754437](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20250212172754437.png)

idle - 空隙状态

fetching - 抓取状态

error - 错误状态

分析：在空闲状态时发生点击事件，进入取网页状态，然后如果在取网页状态下发生了失败的事件那么进入error状态，然后重试，回到取网页状态，如果成功回到空闲状态。



计算机系统都是状态机

考虑一个简单的计算机系统：程序直接运行在CPU上（无操作系统）

![image-20250212173839838](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20250212173839838.png)

C程序的状态机模型

![image-20250212174114127](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20250212174114127.png)

![image-20250212174530798](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20250212174530798.png)

S0状态的PC=2，事件就是这一行int x = 1，S0和事件使得状态转移到S1以此类推



将复杂语句拆分成若干简单语句进行理解

![image-20250212174955110](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20250212174955110.png)

C intermediate Language（CIL工具）



C语句的语义：C语言标准手册

https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html



C语言是否真的从main()第一条语句开始执行？strace

int main() {while (1); return 0;} 如果strace查看这个程序时，一来就卡住，说明就是从main第一条语句开始运行，否则则不是

![image-20250212180149103](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20250212180149103.png)

然后把while(1)去掉，发现在return之后还有操作

![image-20250212180258065](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20250212180258065.png)