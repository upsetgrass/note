# QEMU是什么

QEMU（**Quick Emulator**）是一个 **开源的模拟器和虚拟机**，用于模拟不同架构的 CPU 及其外设，也可以作为一个轻量级的虚拟化工具运行操作系统。

**全系统模拟（System Emulation）**

- 模拟 **完整的计算机系统**，包括 CPU、内存、磁盘、网络、外设等。
- 例如：在 **x86 机器上运行 RISC-V 或 ARM** 的操作系统。
- 适用于 **操作系统开发、嵌入式系统仿真** 等场景。

**用户模式仿真（User-mode Emulation）**

- 允许 **在不同架构的主机上运行外部架构的应用程序**。
- 例如：在 **x86 电脑上运行 RISC-V 编译的 ELF 可执行文件**，用于交叉测试。

**虚拟器（KVM 模式）**

- 结合 **KVM（Kernel-based Virtual Machine）**，可以高效地运行虚拟机，类似 **VMware、VirtualBox**。
- 例如：在 **Linux 上运行完整的 Windows 或 Linux 系统**。

![image-20250326094743149](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20250326094743149.png)

从本质上看，虚拟出的每个虚拟机对应 host 上的一个 Qemu 进程，而虚拟机的执行线程（如 CPU 线程、I/O 线程等）对应 Qemu 进程的一个线程。下面通过一个虚拟机启动过程看看 Qemu 是如何与 KVM 交互的。





# KVM、QEMU、QEMU-KVM、libvirt简介

## KVM

KVM-基于内核的虚拟机，作为Linux的一个内核扩展，使得Linux具备了充当Hypervisor（虚拟机控制程序）的功能，从而在Linux的CPU硬件支持虚拟化扩展（VT-x / AMD-V）并启用了KVM模块的情况下，可以运行多个独立的虚拟机（VM），每一个虚拟机内可以运行一个完整的操作系统，有自己的CPU、内存、存储、并且可以独立运行应用程序，用作虚拟机监控程序的物理硬件称为主机，使用其资源的虚拟机则成为虚拟客户机。

ps：Hypervisor亦称VMM（Virtual Machine Monitor）

使用KVM前提：

- 检查CPU是否支持虚拟化

Intel处理器需要支持VT-x，对应的指令扩展是vmx

AMD处理器需要支持AMD-V，对应的指令扩展是svm

`egrep -c '(vmx|svm)' /proc/cpuinfo`

返回值>0，说明CPU支持，返回值=0，CPU不支持，或者BIOS未启用VT-x或者AMD-V

启用VT-x或AMD-V：进入BIOS/UEFI，找到Intel VT-x / AMD-V相关选项，开启后重启系统



- 检查Linux内核启用KVM模块

`lsmod | grep kvm` - 检查KVM内核模块是否加载

有输出，说明KVM模块已加载，否则需要手动加载：
`sudo modprobe kvm`
`sudo modprobe kvm_intel  # Intel CPU`
`sudo modprobe kvm_amd    # AMD CPU`

如果这里报错，那么说明当前Linux内核未编译KVM支持，需要重新编译或升级内核



- 检查Linux内核是否编译支持KVM

`grep CONFIG_KVM /boot/config-$(uname -r)`

如果输出类似：
`CONFIG_KVM=y`
`CONFIG_KVM_INTEL=m`
`CONFIG_KVM_AMD=m`

y - 内置模块    m - 可加载模块

- Guest架构和host架构需要相同，仅用KVM运行不同架构Guest必然失败，因为KVM依赖Host CPU直接执行指令，而跨架构场景必须依赖QEMU的软件模拟。

  

虚拟机监控程序需要操作系统级组件来运行虚拟机，例如内存管理器、进程调度程序、输入/输出（I/O）堆栈、设备驱动程序、安全管理器、网络堆栈等。KVM 是 Linux 内核的一部分，因此，其包含上述所有组件，并且在各组件支持了虚拟化技术后，能够提升对应的性能

![image-20250326153926545](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20250326153926545.png)

每个虚拟机均作为一个常规的 Linux 进程来实现，由标准的 Linux 调度程序进行调度，且配有专用虚拟化硬件：如网卡、图形适配器、CPU、内存和磁盘——对于这个虚拟机的视角，它认为自己有这些硬件组件，而这些硬件组件由KVM提供（KVM对于VM来说就是硬件管理层）

相较于传统的Hypervisor需要自行实现一套完整的资源管理系统，而KVM直接复用Linux的资源管理机制，不需要重新开发驱动、网络，并且支持硬件虚拟化，运行效率接近原生

![image-20250326151942162](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20250326151942162.png)

## QEMU

QEMU是一个开源仿真器和虚拟机监控器（VMM）。在纯软件仿真模式下，它通过动态二进制翻译（Tiny Code Generator, TCG）模拟完整的硬件环境，支持跨架构运行（如ARM Guest运行在x86 Host上），但性能显著低于原生环境。

在同架构场景中（Host和Guest的硬件架构相同），QEMU通常与KVM协同工作：KVM内核模块利用CPU的硬件虚拟化扩展（如Intel VT-x/AMD-V）直接执行Guest的CPU指令，并通过内存虚拟化技术（如Intel EPT/AMD RVI）优化Guest的内存访问；而QEMU负责模拟虚拟设备（如磁盘、网卡）、处理I/O操作以及提供用户界面（如命令行、图形化显示），从而实现接近物理机的性能。

在不同架构的场景中，是无法使用KVM的，因为Host CPU无法直接执行其他架构的指令，所以此时只能通过QEMU的纯硬件模拟，将Guest的指令逐条翻译为Host的指令（KVM的实现是架构相关的）

不管是相同架构还是不同架构，最终VM中的指令，都终均由 Host 的物理硬件完成计算

![image-20250326163919527](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20250326163919527.png)

QEMU作为仿真器时，就是用于跨架构模拟，将Guest指令通过动态二进制翻译逐条翻译成Host指令，完整模拟Guest架构的硬件环境

QEMU作为VMM时，就是在启用KVM的情况下，将Guest指令直接交由Host进行执行，此时QEMU仅模拟部分设备

