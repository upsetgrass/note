# 非自有软件

error: Package ‘parsec-bin-150_97c’... has an unfree license (‘unfree’), refusing to evaluate.



export NIXPKGS_ALLOW_UNFREE=1



# derivation派生

是描述构建一个软件包所需的所有信息：输入、构建脚本、环境变量、平台信息

pkgs.mkShell{...}调用的结果就是一个派生



# .nix结构

```
{ pkgs ? import <nixpkgs> {} }:  # (A) 函数定义/参数
let                            
xxx							   # (B) 局部变量定义
in      
pkgs.mkShell { ... }           # (C) 最终表达式（函数结果）
```

整个文件简化表达为：`{ attrName, ... }: expression`

真个文件就是一个函数，返回值就是pkgs.mkShell的结果，整个let in结构就是函数体

开头的{}:函数定义部分是为了能够在`nix-build` `nix-shell`时使用--arg args1 value







如果去掉函数定义部分，那么整个文件退化成表达式，无法通过参数控制任何参数





# pkgs



## mkShell

pkgs.mkShell调用pkgs的mkShell函数，这个函数创建了nix-shell环境，包含了特定依赖和配置的沙箱环境

```
pkgs.mkShell{
	buildIputs = [...];
	shellHook = ''	
	'';
}
```





```
buildInputs[
	pkgs.buildPackages.gcc
    pkgs.glibc.static
    pkgs.binutils
]
```

mkShell中的buildInputs属性是一个依赖参数列表，属性列出了进入 shell 环境时需要添加到 `$PATH` 和其他环境变量中的软件包，这使得你可以在 shell 中直接使用这些工具 **在buildInputs中定义的工具是可以不需要路径直接使用的**



PS：这里pkgs.buildPackages.gcc和pkgs.gcc，前者是用于多阶段，需要区分本机和目标机（需要交叉编译的场景），后者就是简单的gcc



shellHook属性是一个shell启动脚本，当用户使用nix-shell环境，会执行这个脚本

```
shellHook = ''
    echo "[本地环境]"
    echo -n "gcc: " && which gcc && gcc --version | head -n1
    echo "[RISC-V 交叉编译环境]"
    echo -n "riscv64-unknown-linux-gnu-gcc: " && which riscv64-unknown-linux-gnu-gcc && riscv64-unknown-linux-gnu-gcc --version | head -n1
    export SYSROOT=${pkgs.pkgsCross.riscv64.glibc.static}
    export CC=riscv64-unknown-linux-gnu-gcc

    echo "目前只支持riscv64; x86_64(系统态有问题), aarch64（未添加）, arm（未添加）, mips(系统态有问题), i386（未添加）"
    echo
    echo "run test: nix-build top/test.nix"
  '';
```

指令就直接放在最外围''    '';中间的任意位置

这里的echo "XXX"——输出文本并换行

echo -n "XXX" —— 输出后不换行







## binutils

pkgs.binutils就是二进制工具集，是GNU的一部分，包含as、ld、ar、objdump、readelf等二进制工具，确保编译本地工具或者交叉编译工具时有配套的链接器和汇编器可以使用







# nix-shell --pure

纯洁沙箱





# 临时沙箱环境

nix-shell -p git vim nodejs

临时进入一个包含git vim nodejs包的nix沙箱环境

exit退出shell后环境消失





# repl选项

这里需要看手册



# 