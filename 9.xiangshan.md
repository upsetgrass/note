香山处理器是乱序六发射结构设计，目前支持 RV64GCBK 扩展（具体指令集字符串为 `RV64IMAFDC_zba_zbb_zbc_zbs_zbkb_zbkc_zbkx_zknd_zkne_zknh_zksed_zksh_svinval_zicbom_zicboz` ）。香山处理器前端流水线包括分支预测单元、取指单元、指令缓冲等单元，顺序取指。后端包括译码、重命名、重定序缓冲、保留站、整型/浮点寄存器堆、整型/浮点运算单元。我们将访存子系统分离开，包括两条 load 流水线，两条 store addr 流水线，两条 store data 流水线，以及独立的 load 队列和 store 队列，store buffer 等。缓存包括 ICache、DCache、L2/L3 Cache (HuanCun)、TLB 和预取器等模块。





前端设计关注芯片的功能性和逻辑设计：芯片做什么？如何实现功能？RTL设计、仿真与验证、综合，输出门级网表

后端设计关注芯片的物理实现：芯片如何将前端设计的逻辑在硬件中实现。布局规划、时钟树综合、布局布线，输出GDSII文件（用于芯片制造的标准格式）

# 前段流水线

南湖架构采取了一种分支预测和指令缓存解耦的取指架构，分支预测单元提供取指请求，写入一个队列，该队列将其发往取指单元，送入指令缓存。 取出的指令码通过预译码初步检查分支预测的错误并及时冲刷预测流水线，检查后的指令送入指令缓冲并传给译码模块，最终形成后端的指令供给，前端整体架构如下图所示：

![image-20241225100102713](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20241225100102713.png)

## 分支预测

分支预测单元（Branch Prediction Unit，BPU）采用一种多级混合预测的架构，其主要组成部分包括下一行预测器（Next Line Predictor，以下简称 NLP）和精确预测器（Accurate Predictor，以下简称 APD）。其中，NLP 是一个uBTB (micro BTB)，APD 由 FTB、TAGE-SC、ITTAGE、RAS组成。NLP 提供无空泡的预测，在预测请求的下一拍就可以得到预测结果。APD 各组成部分的延迟在 2、3 拍。其中，FTB、TAGE、RAS 的延迟为 2 拍；SC、ITTAGE 的延迟为 3 拍。一次预测会经历三个流水级，每一个流水级都会产生新的预测内容。这些分布于不同流水级的预测器组成了一个覆盖预测器(overriding predictor)。

![image-20241225104012964](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20241225104012964.png)

### 顶层模块BPU

BPU是**分支预测器**的顶层模块，包含覆盖**预测逻辑**和**流水线握手逻辑**，**全局分支历史管理**。

（1）流水线握手逻辑是用于协调数据传递的机制，确保不同阶段之间的数据传递有序可靠的。BPU的各个**流水级**都会与取值目标队列FTQ连接，当第一个预测流水级存在有效预测结果，或者后续预测流水级产生不同的预测结果，与FTQ的握手信号的有效位都会置高。

（2）**全局分支历史**管理接近完全准确，由以下三条进行保证：

1. 推测更新：每次预测都会根据**预测块**内的**条件分支指令**个数和预测方向（预测方向就是分支指令是否跳转）计算新的全局历史，并在新的预测中使用

2. 覆盖逻辑中加入全局历史的比较：一旦更新后全局历史与之前流水级的结果不同（条件分支个数或执行结果不同），同样会**冲刷流水线**并重新开始预测    **这一点不太懂，是对同样的指令会预测两次？两次不同就认为有问题？为什么不可能是两次预测错的都相同呢？**

3. 预测后存储全局历史的副本：在预测结束后，当次预测使用的全局历史会存储到 FTQ 中，在误预测恢复时读出并送回 BPU

ps：流水级是流水线中的不同阶段

ps：全局分支历史：记录程序中所有分支指令的跳转行为，用于分支预测器的辅助预测的依据之一，是一串由位构成的序列，1表示跳转，0表示未跳转，若全局历史寄存器的宽度为8位，那么全局分支历史就会记录最近八位的分支指令的行为。

ps：冲刷流水线：清除当前流水线中的指令，并重新加载正确的指令流。

ps：推测更新中只是针对条件分支指令，对于无条件，其跳转结果是确定的，无需预测；对于间接分支预测，目标地址通过多变，很难用简单的taken-1 / not taken-0 进行描述（其一般由Target address Cache，TAC或者BTB的方法进行处理）

ps：分支预测器：预测程序执行过程中**分支指令**的执行路径，通过猜测分支指令是否跳转、跳转目标地址，减少因分支指令引起的流水线停顿（Pipeline stall）和性能损失。具体而言，在分支指令未完全解析出来时，提前猜测分支的方向和目标地址，从而继续执行指令流。

ps：分支指令：有4类： 1）无条件分支指令-不依赖任何条件，执行时直接跳转到目标地址，比如汇编语言的JMP、JUMP指令     2）条件分支指令-根据某个条件的真假决定是否跳转，成立跳转，不成立**顺序执行**下一条指令，例如汇编的BEQ（Branch if Equal）、BNE（Branch if Not Equal）    BEQ R1，R2，target  ；如果R1和R2寄存器相等，那么跳转到target地址   3）间接分支指令-跳转地址不是直接给出的，而是存储在某个寄存器或内存中，一般用于实现函数指针、虚函数表等机制 JMP [R1]  ; 跳转到寄存器R1指向的地址     4）函数调用与返回指令-改变控制流以及调用子程序（函数）或从子程序返回，汇编的CALL用于调用函数，RET用于返回主程序，分支指令是用于实现控制结构的if-else、for、while、goto等程序流动逻辑 

ps：顺序执行：按照地址递增的顺序（线性顺序）依法执行。分支指令会引起这种顺序的改变，使得程序跳转到其他指令地址执行。

ps：预测块：分支预测单元每次给取值目标队列FTQ的请求基本单位，描述了一个连续取指请求的范围，以及其中分支指令的情况

### 下一行预测器

下一行预测器旨在用较小的存储开销提供一个**无空泡**的快速预测流。它的功能主要由uBTB提供。对于给定的起始地址 PC（Program Counter），uBTB对从 PC 开始的一个预测块做出整体预测。

uBTB是微分支目标缓冲，其基于分支历史和PC低位异或索引来存储预测信息，直接提供了下一步的指令流预测：（1）下一个预测块的起始地址nextAddr（2）当前预测块中是否发生分支指令跳转taken（3）跳转指令相对起始地址（PC地址）的偏移量cfiOffset。提供分支指令的相关信息以更新分支历史，包括是否在条件分支跳转takenOnBr，块内包含分支指令的数据brNumOH



ps：PC：存储下一条将要执行的指令的地址

ps：分支历史和全局分支历史不同，对于分支历史，是针对一条分支指令B1，最近的执行的行为为. ；对于全局分支历史，是针对程序，比如程序中B1指令的行为XXX，B2指令的行为XXX...

ps：PC的低位：标识指令在缓存中的位置或地址块的局部特征。

ps：异或操作，将分支历史和PC的低位进行异或，生成一个索引，用来查询uBTB的存储表。







## 取指目标队列

取指目标队列（Fetch Target queue，FTQ），也称缓冲队列



## 取指单元

取指单元（Instruction Fetch Unit，IFU）



## 指令缓存



## 译码单元







# 后端流水线



# 访问子系统



# 缓存层次结构





