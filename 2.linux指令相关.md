![image-20250211174326742](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20250211174326742.png)、

这个Busybox是为嵌入式准备的工具包，标准linux都可以使用



# 符号链接

是Linux下的快捷方式，符号链接将一个文件的路径以文件的形式拷贝到了另一个目录中

sudo ln -s [文件**绝对**路径] [目标路径]

sudo ln -s ~/download/Typora /usr/local/bin/typora

若是遇到上述情况，还需要在~/.bashrc 或者~/.profile目录中加上

`export PATH=$PATH:/usr/local/bin` —— 将该路径设置为PATH环境变量

`source ~/.bashrc`  启用环境变量

`sudo ln -s ~/zotero.desktop ~/.local/share/applications/zotero.desktop` -这个指令也就是说，如果一个软件有.desktop，那么可以软连接到桌面图片



# 解压文件

.tar.gz文件用

`tar -zxvf [解压文件]`

`-z` 表示解压 gzip 压缩文件

`-x` 表示解压 

`-v` 表示显示解压过程（可选）

`-f` 表示指定文件名

（记忆，键盘zxcv中的c向上移动了一个位置）



# 压缩文件

tar -czvf [压缩文件名] [要压缩的所有文件或文件夹]

`-z`：使用 `gzip` 压缩

`-c`：创建一个新的压缩文件 create

`-v`：显示压缩过程

`-f`：指定文件名



# tree

简易观察项目结构树

tree . 查看当前目录的树

tree -L [layer] .     -L选项，显示目录的深度， >=1，

tree -d .       只显示目录，不显示文件

tree -h .       显示文件和目录的大小

-a 显示所有文件，包括隐藏文件

-I 大写i，排除匹配的文件或目录，tree -aI "*.log"

# 指令补全

在~/.bashrc中的文件末尾添加：

```
if [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
fi
```

然后source ~/.bashrc即可



# 查看文件内容

wc -l filename --查看文件行数



# find

find [指定路径] -name "*.desktop"    在指定路径下递归寻找以.desktop结尾的文件

sudo find / -name "main.py"   寻找整个系统中的main.py

find . -name "*.[ch]"  查找当前路径下.c和.h文件



# 添加desktop

```desktop
[Desktop Entry]
Name=typora
Comment=Typora Markdown Editor
Exec=/usr/local/bin/typora %U
Icon=typora
Terminal=false
Type=Application
Categories=Utility;TextEditor;
```

在~/Desktop路径下创建一个typora.desktop，将上述内容copy到里面

Name就是应用显示的名字

Exec是软件的执行文件的路径

Icon是应用的图标，可以随便自行找.png .jpg之类的，可以留空使用默认图标

Terminal可以防止软件不在终端中打开



此时在桌面上就有一个软件图标，但是还需要sudo chmod +x typora.desktop

如果想要放在应用菜单，那么就：

`sudo mv typora.desktop /usr/share/applications/typora.desktop`	





# 进程查看

ps

ps -ef查看进行中的进程



# 进程杀死

kill -STOP [pid] 可以杀死进程  STOP的编码是8，所以也可以kill -8

如果一个程序无法打开，点击无响应，可能是假死问题，可以通过ps -ef | grep [进程名]   

eg：ps -ef | grep weixin   然后把weixin的根进程杀死，比如下图中的2004007就是根进程的PID，也是其他weixin子进程的PPID或者PPID的PPID

![image-20241226110618800](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20241226110618800.png)





# 字体问题

目前没有整理所有的字体问题，主要是遇到linux下钉钉显示问题，通过修改字体，问题得到解决

```bash
gsettings set org.gnome.desktop.interface gtk-theme 'Adwaita'  
gsettings set org.gnome.desktop.interface font-name 'Ubuntu 11'  
```





# 实用命令

ping www.baidu.com 查看网络基本状况

df / -查看磁盘使用情况

fdisk /dev/sdb - 磁盘分区



grep "\bint i\b" a.c 查找文件中定义变量i的位置

\bint i\b - 正则表达式，\b单词边界

![image-20250211171508349](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20250211171508349.png)

wc a.c 统计文件的行数、单词数、字符数  wc针对文本文件进行处理

![image-20250211171631795](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20250211171631795.png)

iconv -f gbk -t utf-8 file.txt - gbk->utf-8 文件编码转换



# 比较文件

vimdiff file1 file2  - 文本文件的比较

diff file1 file2 - 非文本文件的比较

![image-20250211172319634](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20250211172319634.png)

第一个文件的第六行与第二个文件的第五行不同

md5sum file1 file2 - 非常大的文件的比较



列出一个C语言项目中所有被包含过的头文件

find . -name "*.[ch]" | xargs cat | grep "^#include" | sort | uniq

xargs将find的所有输出作为参数给到cat，然后将cat的结果让grep进行筛选出所有以#include为开头的行并并按照字符顺序进行sort排序，并使用uniq去重

| - 管道，将左边命令的输出作为右边命令的输入



# strace

LInux工具如何运行？

1、看源码（source） 得知每一处静态细节、较为繁琐

2、看踪迹（trace） 了解运行动态行为，不全面，容易理解

踪迹工具strace（system call trace）记录程序运行过程中的系统调用信息：通过观察程序运行过程中发生的系统调用，可以大致了解程序关键行为 

strace ls  查看指令ls的系统调用



ls如何被找到？

strace -f bash -c "ls" 

-f：表示在 bash 进程中创建的任何子进程也将被跟踪。例如，如果 bash 启动了 ls，strace 会跟踪 ls 进程的系统调用。

bash：执行 bash 这个命令，这里是启动一个新的 Bash shell。

-c：让 bash 执行一个命令，并在执行完成后退出。它后面的字符串 "ls" 就是需要执行的命令。

"ls"：在 bash 中执行的命令

strace -f bash -c "abcde"  不管是什么指令，都会去寻找

![image-20250212150016680](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20250212150016680.png)



环境变量

echo $PATH

可以将被美元符修饰的字符所指的变量的内容拿出来

![image-20250212150253413](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20250212150253413.png)

这里就能够发现，上面strace -f 寻找ls的过程就是按照PATH系统路径的内容和顺序进行寻找的



命令 - 脚本/C程序



![image-20250212162055905](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20250212162055905.png)

![image-20250212162120332](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20250212162120332.png)

![image-20250212162217360](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20250212162217360.png)

int argc - 命令行参数数量

argv - 从命令行传递给程序的每个参数

envp - 访问系统的环境变量

![image-20250212164759887](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20250212164759887.png)



# tmux

https://www.ruanyifeng.com/blog/2019/10/tmux.html



# QEMU

如果想要在ARM架构上运行RISC-V架构生成的二进制文件，那么就需要QEMU

sudo apt install qemu-user

sudo apt install qemu-user-static

sudo apt-get install riscv64-linux-gnu-glibc

sudo apt install binfmt-support

sudo update-binfmts --enable qemu-riscv64

如果提示某些工具缺失，可以先sudo find / -name XXX

然后把缺失的文件放到/lib/下面

此时可以直接运行RISCV生成的可执行文件，当然也可以qemu-riscv64 ./a.out的方式执行可执行文件



# conda

下载流程

https://www.anaconda.com/docs/getting-started/miniconda/install#macos-linux-installation:how-do-i-verify-my-installers-integrity

uname -m 看本机架构

在第七部时 一般选择

- No - `conda` will not modify your shell scripts. After installation, if you want to initialize, you must do so manually. For more information, see [Manual shell initialization](https://www.anaconda.com/docs/getting-started/miniconda/install#miniconda-manual-shell-init-linux).

no之后需要自己去搞路径，

vim ~/.bashrc 

`export PATH="$HOME/miniconda3/bin:$PATH"`

`source ~/.bashrc`

`conda init`



`conda activate base`

`conda deactivate`

`conda config --set auto_activate_base false` - 禁止新会话自动进入base环境



`pip install -r requirements.txt` - 下载本地requirements.txt



`ipython --TerminalIPythonApp.file_to_run=your_notebook.ipynb` - 直接运行

`jupyter nbconvert --to script your_notebook.ipynb` - .ipynb 转换为.py