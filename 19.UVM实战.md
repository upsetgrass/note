[TOC]



# 引入

![image-20251113161412375](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20251113161412375.png)

需求说明书通过IC工程师细化为特性列表：

- 设计工程师将其转换为规格说明书，阐述设计方案，描述接口时序信号，使用的RAM资源，如何处理异常。

- 验证工程师根据特性列表写出验证规格说明书，说明如何搭建验证平台，如何保证验证完备性，如何测试每一条特性，如何测试异常情况。



设计人员用verilog/Chisel将特性列表转换成RTL代码，验证人员写SystemVerilog/Cocotb搭建验证平台，验证设计人员写的这些代码（称为DUT，design under test）的正确性



验证的点包括：

- DUT的行为表现是否与特性列表中要求的一致。
- DUT是否实现了所有特性列表中列出的特性。
- DUT对于异常状况的反应是否与特性列表和设计规格说明书中的一致，如中断是否置起。
- DUT是否足够稳健，能够从异常状态中恢复到正常的工作模式。



附录一：SystemVerilog使用 【TODO】



# UVM验证平台

UVM是systemverilog语言的类库和一套规则

| **特性**     | **SystemVerilog**                                            | **UVM (Universal Verification Methodology)**                 |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **本质**     | **硬件描述/验证语言 (HDL/HVL)**                              | **验证方法学 / 类库**                                        |
| **作用**     | **提供基础能力**：提供时序控制 (`always`, `@`), 模块化 (`module`, `interface`), 随机化 (`rand`), 以及最重要的 **面向对象编程 (OOP)** 能力 (`class`, `extends`, `virtual`)。 | **提供验证框架**：利用 SystemVerilog 的 OOP 特性，定义了一套标准的组件（Agent, Driver, Sequencer, Scoreboard）和一套标准的运行规则（Phase 机制）。 |
| **核心**     | **语言特性**：`class`, `interface`, `task`, `function`       | **类库**：`uvm_component`, `uvm_driver`, `uvm_sequence_item`, `uvm_config_db` |
| **关系**     | UVM 的**基石**。没有 SystemVerilog 的 OOP 能力，UVM 无法存在。 | SystemVerilog **的应用**。将语言能力组织起来，形成可复用、可扩展的验证平台。 |
| **可独立性** | 可以独立存在，编写 RTL 代码或传统的 Testbench。              | **不能** 独立存在，必须依赖 SystemVerilog 的编译器和运行时环境。 |

验证用于找出DUT中的bug，这个过程通常是把DUT放入一个验证平台中来实现的

input-driver模块给DUT施加激励，给验证平台需要模拟DUT的真实使用情况

- 正常激励
- 异常激励



output-scoreboard（checker），在验证平台要能够根据DUT输出到scoreboard的结果来判断DUT的行为是否与预期相符合，monitor模拟器收集DUT的输出并传递给scoreboard

- 判断什么？
- 判断标准是什么？即，预期结果

例如：DUT是一个加法器，当给该DUT激励1+1，那么期望输出2，那么在验证平台中也需要通过软件模拟计算一次1+1，这个软件的模拟就是参考模型（reference model）

![image-20251115153824975](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20251115153824975.png)

![image-20251115153812636](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20251115153812636.png)

**Agent** 是 UVM 验证平台中的一个核心组件，用于封装**和**管理**一个特定**接口**上所需的所有验证功能。可将Agent看作是验证平台连接到DUT（Design Under Test，待测设计）的“适配器”或“接口管理器”

![image-20251115154131523](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20251115154131523.png)

Sequence 是 UVM 验证平台中用于定义和生成 激励（Stimulus） 的组件。它定义了测试平台应该对 DUT 做什么以及按照什么顺序做。Sequence 内部描述的是一系列高层级的事务



使用UVM的第一原则：验证平台的所有组件需要派生自UVM提供的类

UVM_Class_Reference_Manual_1.2.pdf

https://accellera.org/images/downloads/standards/uvm/UVM_Class_Reference_Manual_1.2.pdf



## UVM Phase:

![image-20251117004202882](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20251117004202882.png)

在run_phase才能执行耗时的任务（task）并与RTL信号交互



VIF（Virtual Interface，虚拟接口），连接UVM的组件-软件域和RTL-硬件域的桥梁，VIF是一个类型，通过uvm_config_db将VIF的句柄传递给Driver，Driver可以通过该句柄直接访问和修改DUT接口上的信号值



## uvm_info

uvm_info是信息打印宏，以反引号`（数字1左边）开头，比verilog的display强大，可以将输出分类、设置冗余级别，关键信息设置为UVM_LOW，

``uvm_info("my_driver", "data is drived", UVM_LOW)`

![image-20251116105124809](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20251116105124809.png)

drv是driver在UVM树中的路径索引，是逻辑节点信息，可以用get_full_name函数在uvm树中的节点内打印（打印当前节点的uvm树路径索引），[my_driver]就是用户自定义信息分类，data is drived就是打印信息。



除了uvm_info，还有uvm_error uvm_warning宏



`include "uvm_macros.svh" 包含了众多宏定义



```
// .<DUT 端口名>(<顶层信号名>)
dut my_dut( .clk(clk),
            .rst_n(rst_n),
            .rxd(rxd),
            .rx_dv(rx_dv),
            .txd(txd),
            .tx_en(tx_en));
```



## wire和reg

wire和reg：

![image-20251116114851096](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20251116114851096.png)

wire由外部驱动，不能在always里面赋值

reg是寄存器，只能在always、initial中赋值



## 周期&频率计算

时钟周期和频率计算：

![image-20251116115616170](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20251116115616170.png)



## @ $ `

| **符号** | **语法背景**                           | **作用**                                                     | **示例**                                 |
| -------- | -------------------------------------- | ------------------------------------------------------------ | ---------------------------------------- |
| **`@`**  | SystemVerilog/Verilog                  | **事件控制**。用于过程块（`always`, `initial`, `task`, `function`）中，使程序阻塞，直到括号内的事件发生。 | `@(posedge clk)`：阻塞，直到时钟上升沿。 |
| **用途** | 实现时序逻辑或等待硬件信号的同步变化。 |                                                              |                                          |



| **符号** | **语法背景**                                                 | **作用**                                                     | **示例**                          |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | --------------------------------- |
| **`$`**  | SystemVerilog/Verilog                                        | **系统调用**。调用仿真器或语言内置的功能，而不是用户自定义的硬件逻辑。 | `$finish()`：系统任务，结束仿真。 |
| **用途** | **仿真控制**（`$finish`, `$stop`）、**输出**（`$display`, `$write`）、**随机数生成**（`$urandom_range`）。 |                                                              |                                   |



| **符号** | **语法背景**                       | **作用**                                                     | **示例**                           |
| -------- | ---------------------------------- | ------------------------------------------------------------ | ---------------------------------- |
| **`**    | SystemVerilog/Verilog **预处理器** | 在代码被编译前，由预处理器进行文本替换、文件包含或编译条件控制。 | `include "file.svh"`：包含文件。   |
|          |                                    | **宏调用**：调用由 `define` 定义的宏。                       | `uvm_info(...)`：调用 UVM 报告宏。 |
| **用途** | 简化重复代码、条件编译、导入文件。 |                                                              |                                    |





## 常见关键字

模块和连接关键字（硬件结构）

| **关键字**                   | **作用**                                        | **示例**                            |
| ---------------------------- | ----------------------------------------------- | ----------------------------------- |
| `module` / `endmodule`       | 定义顶层或 RTL 硬件模块的边界。                 | `module top_tb; ... endmodule`      |
| `input` / `output`           | 声明模块端口的方向。                            | `input clk;`                        |
| `interface` / `endinterface` | 定义连接 DUT 和 TB 的信号束，通常用于创建 VIF。 | `interface my_if; ... endinterface` |
| `wire` / `logic`             | 线网类型，用于连接信号（`logic` 更通用）。      | `wire txd;`                         |
| `reg` / `var`                | 寄存器类型，用于存储数据（在过程块中赋值）。    | `reg rst_n;`                        |



时序和过程控制关键字（行为）

| **关键字**          | **作用**                                                     | **示例**                              |
| ------------------- | ------------------------------------------------------------ | ------------------------------------- |
| `always`            | **持续执行**：创建一个无限循环的过程块，常用于硬件逻辑建模。 | `always @(posedge clk) begin ... end` |
| `initial`           | **一次执行**：仿真开始时执行一次，常用于激励、时钟和复位生成。 | `initial begin clk = 0; ... end`      |
| `begin` / `end`     | 过程块内语句的分组。                                         | `initial begin ... end`               |
| `for` / `while`     | 循环语句，常用于在 `initial` 或 `always` 块中生成重复激励。  | `for (int i=0; i<N; i++) ...`         |
| `task` / `function` | 定义可重复使用的过程。`task` 可以包含时序控制（阻塞），`function` 不可以。 | `task drive_data(); ... endtask`      |
| `fork` / `join`     | 并行执行多段代码（并发）。                                   | `fork task_A(); task_B(); join`       |



面向对象编程（OOP）关键字（UVM 结构）

| **关键字**           | **作用**                                          | **示例**                                           |
| -------------------- | ------------------------------------------------- | -------------------------------------------------- |
| `class` / `endclass` | 定义 UVM 中所有组件的骨架（如 Driver, Monitor）。 | `class my_driver extends uvm_driver; ... endclass` |
| `extends`            | 实现类的继承关系。                                | `class my_driver extends uvm_driver;`              |
| `new`                | 类的构造函数（实例化对象）。                      | `drv = new("drv", null);`                          |
| `virtual`            | 定义虚方法，是实现多态的基础。                    | `virtual task run_phase();`                        |





## SystemVerilog内置功能（系统任务、函数）

IEEE Standard for SystemVerilog—Unified Hardware Design.pdf

第二十章

![image-20251116123512755](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20251116123512755.png)



系统任务：

| **任务**              | **作用**                                | **示例**                         |
| --------------------- | --------------------------------------- | -------------------------------- |
| `$display` / `$write` | 打印信息到控制台，`$write` 不自动换行。 | `$display("Time is %t", $time);` |
| `$finish`             | 立即终止仿真。                          | `$finish;`                       |
| `$stop`               | 暂停仿真，进入交互模式。                | `$stop;`                         |
| `$monitor`            | 监控变量，当变量值变化时自动打印。      | `$monitor("Data = %h", data);`   |



常用系统函数

| **函数**         | **作用**                                  | **示例**                     |
| ---------------- | ----------------------------------------- | ---------------------------- |
| `$time`          | 返回当前的仿真时间。                      | `$time`                      |
| `$urandom_range` | 生成指定范围内的随机数。                  | `$urandom_range(1, 100);`    |
| `$sformatf`      | 格式化字符串，常用于 UVM 中构建组件名称。 | `$sformatf("agent[%0d]", i)` |




## 宏调用和预处理指令

预处理指令以`开头，在编译代码前执行文本替换或文件操作

| **指令**           | **作用**                         | **示例**                   |
| ------------------ | -------------------------------- | -------------------------- |
| `include`          | 将另一个文件内容插入到当前位置。 | `include "uvm_macros.svh"` |
| `define`           | 定义文本宏或条件编译变量。       | `define MY_FLAG 1`         |
| `ifdef` / `ifndef` | 条件编译。检查一个宏是否已定义。 | ifdef MY_FLAG ... `endif   |
| `timescale`        | 设置时间单位和精度。             | `timescale 1ns/1ps`        |



UVM宏是使用define定义的，都在uvm_macros.svh文件中定义

1、报告宏

| **宏**        | **级别**       | **作用**                         | **示例**                                   |
| ------------- | -------------- | -------------------------------- | ------------------------------------------ |
| `uvm_info`    | 信息 (INFO)    | 打印一般信息，可被过滤。         | `uvm_info("DRV", "Data sent", UVM_LOW)`    |
| `uvm_warning` | 警告 (WARNING) | 报告潜在问题，不中断仿真。       | `uvm_warning("SCRB", "Mismatch detected")` |
| `uvm_error`   | 错误 (ERROR)   | 报告功能错误，不致命。           | `uvm_error("AGNT", "Invalid state")`       |
| `uvm_fatal`   | 致命 (FATAL)   | 报告严重错误，导致仿真提前结束。 | `uvm_fatal("CONFIG", "VIF not found")`     |

2、factory 和OOP宏

| **宏**                | **作用**                                                   | **示例**                                                     |
| --------------------- | ---------------------------------------------------------- | ------------------------------------------------------------ |
| `uvm_component_utils` | 注册 `uvm_component` 派生类到 UVM Factory。                | `uvm_component_utils(my_driver)`                             |
| `uvm_object_utils`    | 注册 `uvm_object` 派生类（如 Transaction）到 UVM Factory。 | `uvm_object_utils_begin(my_trans) ... `uvm_object_utils_end` |





## factory机制

工厂机制保证了UVM的激励和组件的实现与验证环境的完全解构

集成到了uvm_component_utils





```verilog
module top_tb;
initial begin
	run_test("my_driver");
end
endmodule
```

run_test()会创建my_driver代表的类的实例，并自动调用main_phase

所有派生自uvm_component及其派生类的类都应该使用uvm_component_utils宏注册



## objection机制

uvm在执行完run_phase代码后，仿真不会立刻停止，会检查一个异议计数器（Objection Count），如果异议计数器大于0，那么uvm会保持run_phase阶段，直到所有组件将异议撤销，总计数归为0，此时才会进入timeout计时，这段时间内异议计数器保持为0，才会停止uvm仿真。

而组件**发起异议**和**撤销异议**这两个操作则是分别由raise_objection和drop_objection函数管理



raise_objection 和 drop_objection成对出现，目前可以认为drop_objection是finish函数的替代

raise_objection语句必须在main_phase中第一个消耗仿真时间（time函数打印的时间，与之对应的是CPU时间即运行时间）的语句之前。如$display语句是不消耗仿真时间的，这些语句可
以放在raise_objection之前，但是类似@（posedge top.clk）等语句就不能放在raise_objection前面



## virtual interface

防止上层信号的更名导致下层验证结构的大量修改，有两种办法：

1、使用宏

![image-20251116161635538](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20251116161635538.png)

我们称top.clk是使用绝对路径，将可能会进行更改的信号路径更改为宏，这里则把xxx.clk的xxx部分修改为宏

这就能避免top.clk更名为top.clk_inst.clk这种问题导致的大量修改了

2、使用interface和virtual interface （**还没完全理解，可能还需要看例子[TODO]**）

UVM的组件是class，RTL信号是module或接口中定义的静态硬件结构

interface用于将一组信号打成bundle，在module中可以直接实例化定义的interface结构

对于class结构，就需要使用virtual my_if vif;





数据流动：
![image-20251117000233258](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20251117000233258.png)

![image-20251117003210042](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20251117003210042.png)



## transaction

所有transaction类都需要派生自uvm_sequence_item，之后才能使用sequence机制

![image-20251117095230200](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20251117095230200.png)

my_driver和my_transaction有区别，前者是整个仿真期间都存在，后者有生命周期，在仿真的某一时间产生，经由driver驱动，reference model处理，最终由scoreboard比较完成后，生命周期就结束了

这种有生命周期的类，都派生自uvm_object/uvm_object的派生类，都需要使用uvm_object_utils宏来实现factory机制（而没有使用uvm_component_utils宏）



## env







零散语法

静态数组-非连续存储-bit [7:0] c1;

压缩数组-连续存储-u[7:0];

动态数组-初始时未知大小，需要用new[n] n为期望数组长度-bit[3:0] dyn_arr[]; - 4比特动态数组

$size()可以查看静态数组或动态数组的大小

A[x+:c] = B[y+:c]

A、B是数组，将B数组以y为起点，c为宽度的内容给到以x为起点c为宽度的A中去



![image-20251127155101408](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20251127155101408.png)

![image-20251127155107315](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20251127155107315.png)







汇报：通过UVM实战这本书去学习如何搭建验证平台，从基础概念：DUT、top_tb、具体的uvm组件开始，各自在验证平台中的作用，了解了uvm组件各个phase阶段：build、connect、run、check，以及数据流动：如何将激励从uvm组件（driver）通过VIF句柄给到DUT被测硬件模块，以及DUT如何将响应结果输出通过interface输出到uvm组件（Monitor）

同步的也零碎的学了一些systemverilog的语法和内置的一些基本函数和uvm宏

这周继续通过UVM实战这本书学习验证框架，看到哪种程度？哪些章节？

天界平台？随便发激励看波形，看硬件的