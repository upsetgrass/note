[TOC]

# makefile构建

```makefile
MDs=$(shell find docs/ -name "*.md") \
		$(patsubst src/main/scala/%.scala,docs/%_scala.md,$(wildcard src/main/scala/*.scala))
```

这里有两个部分，从右至左执行，先执行$(patsubst ...)，由于patsubst中内嵌了一个指令，所以执行patsubst之前先执行内嵌的指令wildcard，最后执行find，将最后结果存储到MDs

1、wildcard src/main/scala/*.scala   wildcard是makefile中的关键字，用于简单的字符串匹配，比find效率更高，如果现在src/main/scala中有aplic.scala和imsic.scala两个文件，生成src/main/scala/imsic.scala src/main/scala/aplic.scala ...  

patsubst src/main/scala/%.scala, docs/%\_scala.md，patsubst也是makefile中的关键字，语法是$(patsubst \<pattern>, \<replacement>, \<text>)，也就是将第一步拿到的结果text替换为docs/\*_scala.md

2、shell find docs/ -name \"*\.md\*" 调用shell命令，执行find指令，找到docs目录下的所有md文件（递归寻找），docs/imsic.md docs/aplic.md



然后将两步得到的结果进行拼接，给到MDs

：docs/imsic.md docs/aplic.md docs/imsic_scala.md docs/aplic_scala.md

```makefile
PYSVGs=$(subst _dot.py,_py.svg,$(shell find docs/ -name "*_dot.py"))
```

subst字符串替换，\$(subst from, to, text)  from-需要被替换的子字符串  to-替换后的新子字符串  text-原始文本

所以这个指令的意思就是，先通过find指令寻找到docs/下所有以\_dot.py结尾的文件，将其作为原始文本，将原始文本中所有的\_dot.py替换为\_py.svg，然后将替换后的文件存放到PYSVGs

```makefile
DOTSVGs=$(subst .dot,.svg,$(shell find docs/ -name "*.dot"))
```

DOTSVGs同理，将.dot结尾的替换为.svg

```makefile
doc: $(MDs) $(PYSVGs) $(DOTSVGs)
	mdbook build
```

doc是一个目标，后面这三个是依赖，

MDs是一个引用，\$(MDs)就可以使用MDs存储的内容

如果依赖中有发生变化，在执行make doc时，那么就执行`mdbook build`

无论依赖中是否有更新，都去执行 mdbook build 使用`make -B doc`指令

mdbook build是用于生成可视化文档的

mdbook build执行时会在该目录中寻找book.toml文件，如下所示

```toml
[book]
authors = ["xieby1"]
language = "en"
multilingual = false
src = "docs/"
title = "ChiselAIA"

[output.html]
git-repository-url = "https://openxiangshan.github.io/ChiselAIA/"
mathjax-support = true
```

该book.toml中有两个部分，第一个是关于book的部分：包含了作者，默认语言，是否开启多语言版本、在哪里寻找markdown文件，文档的书名

第二个是关于发布的部分：git-repository-url = "https://openxiangshan.github.io/ChiselAIA/" 这个 URL 是电子书的 GitHub Pages 发布地址。在 mdBook 生成的 HTML 页面中，它会自动加一个“编辑此页”按钮，跳转到该 GitHub 仓库的源码。

此时我们这个地址就可以在README.md中提供出来，使得其他人可以通过超链接找到我们的文档

![image-20250319161402618](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20250319161402618.png)

mdbook build会在book.toml中的src中寻找.md，会将这些.md转换成html电子书

.md中有一个SUMMARY.md，这是 mdbook 的核心文件，定义了书籍的章节结构，mdbook 会根据 SUMMARY.md 中的链接查找并解析 Markdown 文件

对于每个章节的.md，SUMMARY.md 中引用的所有 .md 文件都会被处理。

任何 src 目录下的其他 .md 文件（即使未在 SUMMARY.md 中定义）通常不会被包含在最终的书籍中，除非手动指定。

默认的，对于静态资源、模板文件，需要放在src指定的目录下的子目录（src/images   src/theme  src/css  这里src就是docs）

![image-20250319173436707](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20250319173436707.png)

mathjax-support = true，允许 mdbook 解析 LaTeX 公式，使 Markdown 文件中的数学公式可以正确渲染

这也就说明了，执行mdbook build时为什么mdbook指令知道需要到docs/下寻找.md

```makefile
docs/images/arch_configure_py.dot: docs/images/arch_common.py
docs/images/arch_interrupt_py.dot: docs/images/arch_common.py
docs/images/example_py.dot: docs/images/example_common.py
docs/images/example-axi_py.dot: docs/images/example_common.py
%_py.dot: %_dot.py
	python3 $<
%.svg: %.dot
	dot -Tsvg $< -o $@
	sed -i 's/\([0-9]\+\)pt/\1px/g' $@
```

这里有三个部分，上面四个是依赖关系，例如docs/images/arch_configure_py.dot依赖于docs/images/arch_common.py，这里并没有指定动作，只是告诉make指令谁依赖于谁，也就是当\*\_common.py有了更新，对应的目标就会更新

再来看下面的%\_py.dot: %\_dot.py和%.svg: %.dot，这俩是通配规则，定义了会在当前目录下寻找\_dot.py结尾的依赖，生成同名前缀\_py.dot的目标，定义的动作是python3 \$<  ，但是这里当前目录下是没有\_dot.py的

**这里有些特殊，由于前面四条依赖关系没有指定如何生成XXX_py.dot，所以make会寻找通用规则，此时make发现\_py.dot: %\_dot.py符合上面四条依赖关系的形式，% = docs/images/example，所以此时并不会只在当前路径下寻找符合的后缀，因而这里的动作其实是：python3 docs/images/example_dot.py的形式，这里的通用规则会生成四条依赖**

XXX\_common.py又有什么用呢？这是生成_py.dot的依赖，这个依赖是以import的形式存在于\_dot.py中的，是一种隐式的依赖，如果我们不显式指定，当XXX\_common.py有了更新时，make检测不到import中的更改

下面的%.svg: %.dot，是由于前面的指令的生成了docs/images/XXX_py.dot，所以这里make在.dot在当前目录寻找不到对应的文件时会去使用前面生成的docs/images/XXX_py.dot，从而通过dot指令生成docs/images/XXX.svg

dot语法：dot -Tsvg <对应的.dot文件> -o <目标.svg文件>

以下是sed的具体信息

![image-20250319111322903](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20250319111322903.png)

```makefile
docs/%_scala.md: src/main/scala/%.scala
	markcode $< > $@
```

\$\<是第一个依赖文件$@是目标文件，markcode是一个工具，可以将.scala代码转换成.md，\>是从定向操作，将markcode生成的内容写入到目标文件





# github目录构建

在github中无法使用[TOC]自动构建目录，需要用一些其他方式

```markdown
<!-- vim-markdown-toc GFM -->

* [简介（Introduction）](#简介introduction)
* [使用方法（Usage）](#使用方法usage)
* [相关工作（Related Works）](#相关工作related-works)

<!-- vim-markdown-toc -->
```

\<!-- vim-markdown-toc GFM -->

这是 Vim Markdown TOC 的指令，表示 使用 GitHub Flavored Markdown（GFM）格式 生成目录。

GFM 代表 GitHub Flavored Markdown，即 GitHub 兼容的 Markdown 语法。

\* \[简介（Introduction）](#简介introduction)

这是 Markdown 目录项，[]中是显示的内容，()是指向的内容，指向文档内的 ## 简介（Introduction） 标题。

\<!-- vim-markdown-toc -->

这是 目录的结束标记，插件会在这个区域内自动更新 TOC。



如何使用:

这个目录通常由 Vim 的 markdown-toc 插件自动生成。该插件会解析 Markdown 文件的标题（# ## ### 等）

在 Vim/Neovim 中安装了 vim-markdown 插件：在 Markdown 文件中输入 \<!-- vim-markdown-toc GFM -->

在 Vim 中运行命令：`:GenTocGFM`

目录会自动生成或更新

**该部分当前未能成功使用，暂时用以下方式替代自动更新**

在VSCode中安装：Markdown All in One插件，然后 [查看] - [控制面板] 其中输入：`Markdown All in One: Create Table of Contents ` 

即可在当前.md文件光标所在位置自动添加目录

![image-20250319153710111](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20250319153710111.png)

# 文档结构

github文档结构：

![image-20250319151538785](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20250319151538785.png)

SUMMARY.md中存放目录，以及跳转方式

![image-20250319152103761](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20250319152103761.png)



对于每一个章节，里面的语法都是markdown

![image-20250319153256987](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20250319153256987.png)

下链接中有markdown基本使用：https://markdown.com.cn/basic-syntax/

# 代码生图

以当前的代码为例进行讲解

arch_common.py定义图形结构，包括节点和边

arch_configure_dot.py使用了arch_common.py定义的图形，并使得各种节点和边产生联系



首先分析：arch_common.py







分析：arch_configure_dot.py