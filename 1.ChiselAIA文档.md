ChieslAIA的实现遵循了**RISC-V高级中断架构**，实现与规范之间的差异都视为实现BUG

# RISC-V高级中断架构

RISC-V高级中断架构建立在**RISC ISA（RISC指令集）的中断处理功能**的基础上，增加了对以下方面的支持：

1、来自设备的信息信号中断（MSI）

2、在虚拟监管模式（VS模式）下运行的客户操作系统可直接控制设备中断（作为MSI），从而减少对常规管理程序干预的依赖。

3、为RISC-V硬件线程增加了额外的标准本地中断。

4、本地中断和设备中断的优先级可以混用

5、将本地中断有条件地委托给较低特权级别的处理，包括虚拟机



针对上述文字中的疑问进行以下学习

## 1. RISC-ISA 中断处理功能

![image-20241108111712064](../pic/image-20241108111712064.png)

**触发中断** → **保存状态** → **跳转到处理程序** → **处理中断** → **恢复状态** → **返回正常执行**

### 1.1 中断触发

中断由硬件（外部设备和定时器）或软件触发，CPU会在每个指令周期检查是否有中断信号，并且判断是否满足中断条件（**全局中断使能**、**特定类型的中断使能**），在多个中断信号同事时发时，RISC-V会根据优先级处理。

全局中断使能（Machine Interrupt Enable，MIE）**：本质就是一个bit位，当该位被设置为1时才会响应中断，如果MIE被设置为0，即使有中断信号到达CPU，CPU也不会响应，MIE位于mstatus寄存器中，表示**机器模式**下的全局中断使能（**也就是当MIE位被设置为0，即使中断类型使能被设置为1，也无法响应中断，是中断的全局控制**）

ps：机器模式：RISC-V有三种特权级，分别为机器模式（M模式）、超级模式（S模式）、用户模式（U模式） **———— 这里需要细讲，现在暂时打住**

中断类型的使能：对于每种类型都有对应的使能位，例如MEIE（Machine External Interrupt Enable）用来启用外部中断、MTIE启用定时器中断、MSIE启用软件中断，这些使能位位于mie寄存器中，只有对应中断类型被设置为1，该中断才能被执行

### 1.2 保存上下文状态

在运行中断程序之前，还需要保存原状态信息：

保存当前程序计数器PC到mepc（Machine Exception Program Counter）寄存器

**保存特权级**（Machine Previous Privilege, MPP）和**全局中断状态**（就是MIE）到mstatus寄存器中，以便中断返回后恢复

还可能会保存通用寄存器（x1-x31）、浮点寄存器（f0-f31）、控制状态寄存器、地址寄存器、内存管理寄存器、中断嵌套深度等内容

ps：对于保存全局中断状态的说明：是为了防止以下的情况出现1）中断嵌套场景，在发生中断的过程中，是有可能再次触发其他中断的，所以保存MIE可以控制是否允许在处理当前中断的同时响应其他中断，如果不允许，那么MIE变成了0，中断处理结束，恢复之后MIE就变成0了。   2）中断处理过程中，可能直接不允许其他中断的发生，所以会把MIE变成0，进而在退出后MIE还是0，发生错乱。3）在中断处理过程中，保存的MIE可以确保程序运行环境的一致性，防止中断处理函数对系统状态产生意外的干扰。

ps：对于保存特权级的说明：在1.3部分的By the way说明了中断处理时会提权到机器模式，所以这里需要保存特权级以用于恢复提权之前的特权级。



### 1.3 跳转到中断处理程序

确定中断处理入口地址：CPU从**mtvec寄存器**中获取到，有两种获取模式，应用于不同的场景：

ps：MTVec寄存器（Machine Trap Vector）机器陷阱向量是RISC-V指令集架构的概念，在遇到异常、中断、系统调用时会跳转到一个**预定义**的内存地址执行相对应的处理程序

1、直接模式：所有中断共享一个mtvec入口地址，该地址上，通常会编写一个通用的中断向量处理程序，在这个程序中会读取mcause寄存器（以识别中断的具体类型），从而选择、跳转各自的中断处理程序，通常用于简单系统，或者不需要区分中断入口的应用场景

2、向量模式：不同中断类型有不同的入口地址，这些地址基于mtvec基址加上特定偏移量计算得到，也就说，向量模式下mtvec不再指向统一的入口地址，而是提供了一个基地址+偏移量的方式进入不同类型的中断处理，偏移量是通过访问mcause寄存器存储的中断类型编号得到的，比如mtvec的基地址是0x8240，外部中断的类型是3，那么中断处理的地址就是0x8240+3*偏移单位（4/8），向量模式的优势：快速响应、降低开销，常用于实时系统、嵌入式系统

ps：确定中断处理程序并不需要明确“具体哪个程序调用的中断”，只需要知道是什么设备？是定时器？或者别的中断原因，因为每一种中断原因（硬件/软件）对应的中断处理都是已经预设好的程序，无需确定具体是哪个程序调用的中断。

（By the way，如果中断触发自低特权级（比如用户级），CPU会切换到较高特权级（机器级）执行中断处理程序）



关于mcause寄存器：用于记录中断或异常的原因，是机器模式下的一个重要寄存器，Bit 0：异常/中断标志位 0-异常 1-中断  Bits1-31（1-63）：中断的来源（Bit0 = 1）、异常的类型（Bit0 = 0）



### 1.4 处理中断

执行中断程序：**中断服务程序**（Interupt Service Routine， ISR）根据中断类型进行处理，例如：驱动设备程序的执行、内存的读写、任务调度等，也就是中所述的中断处理程序

更新挂起位：并且中断处理程序通常会清理或更新mip寄存器中对应的中断挂起位，已表明该中断已被响应，更新挂起位的作用：在发起中断后，中断会处于挂起状态，在CPU去响应中断时，挂起的中断并不会立刻清除，只有当在ISR更新挂起位之后，挂起的中断才会清除。

ps：mip寄存器（Machine Interrup Panding）机器中断待处理，该寄存器中的每一个位表示一种中断源的挂起状态，如果某硬件/软件触发了一个中断，那么mip寄存器的对应位会被设置为1，那么表示该中断已经被触发，并等待被处理

ps：为什么中断响应后不立刻更新挂起状态？这是因为可能同一时间有多个同类型的中断源发出中断请求，如果立刻更新的话，那么后面排队的同类型的中断源会立刻把mip寄存器对应的中断位变成1，这样就会造成误判，并且需要注意对于同一类型的中断请求，只有0和1，并不会同时存储/排队多个中断请求（这样能够简化硬件实现，避免了复杂的中断排队机制）

ps：中断控制器是计算机硬件组件（Interrupt Controller），负责管理和处理来自硬件和外设的中断请求，具体而言就是接收、优先级排序并控制中断的传递，其并不在CPU中，而前面提到的mip寄存器、MIE位（mstatus寄存器中）、mie寄存器都在CPU中。中断控制器会监控 `MIP` 寄存器中的位，判断是否有中断源发起了请求，同时根据中断优先级、CPU 的中断使能状态等因素，决定是否将中断信号传递给 CPU。此外，复杂的系统中多个设备可能会产生相同的中断请求，为了防止处理资源浪费，需要提供去抖动（debouncing）和合并请求的功能，这样可以确保只有一个有效的中断信号传递给CPU，此外，中断控制器也设置了中断屏蔽和启用（使能），当然mie寄存器和MIE位已经有了这样的功能，但是在中断控制器中可以更加灵活的针对不同的场景不同的外设进行屏蔽、启用调整，**总体来说中断控制器就是对各个中断源的信息做一个汇总、管理、调度、传递**。

ps：一般而言，对于相同类型的中断，执行的ISR是相同的，只有一些特殊情况下ISR可能会有所不同。 **————（现在不做具体了解）**

ps：ISR执行时一直都是机器模式，所以其有权利在执行的过程中对CPU中的mie、mstatus、mepc等寄存器的信息，这是在执行一些复杂ISR时，需要调整返回后的寄存器存储的内容，以返回正确、合适的特权、中断使能等。



到底是谁让MIP对应位变成挂起状态？硬件？还是中断控制器？





### 1.5 恢复上下文状态

从mepc中恢复之前保存的PC值，确保中断返回后继续执行中断发生前的代码，这里会根据中断的需求有所不同，有些PC存储的是下一条指令执行的地址，有些PC存储的是指令开始的地址，用于重试（异常中断）

中断处理结束后恢复mstatus，CPU会恢复mstatus寄存器中原始特权级和全局中断状态，特权级在中断处理时会进行提权，所以这里需要恢复，而全局中断也可能会被改变，所以这里也会需要进行恢复

如果用了其他的通用寄存器、浮点状态等，都需要进行恢复。

ps：1.5的所有恢复操作都是在执行mret指令时进行的，这里只是阐述需要恢复哪些内容。

### 1.6 返回到正常执行流程

6）返回到正常执行流程

CPU执行mret指令（Machine Return），恢复到中断发生前的特权级和状态，并从mepc恢复的地址处**继续执行原程序**



## 信息信号中断（Message Signaled Interrupts，MSI）

MSI是一种利用**信息信号**的**中断触发机制**，主要用于现代计算机系统中，尤其是在**PCIe总线架构**中，MSI不需要专门的硬件信号线路，而是通过系统**内存**中的特定地址写入数据来发出中断请求。

信号：某种事件或状态的变化，包括了物理的电平变化、逻辑事件的触发、特定条件的触发信号，信号本身不带有信息，而是代表系统中发生的某种特定状态变化的信息，大多数信息就是01信号，在总线控制、外设接口等地方会用到三态逻辑（0-低电平 1-高电平 z-高阻抗），这里只简单的提及。

### 中断触发机制

目前有三种机制

1）基于物理中断线路的中断

传统的硬件中断通常通过 **外部设备的物理信号线路** 来触发。例如，设备（如外设、定时器或其他硬件组件）会通过特定的引脚向 CPU 发送中断请求信号。这些信号可能通过中断控制器进行管理。中断控制器检测到中断信号时，会设置相应的中断标志，通知 CPU 进行中断处理。

2）基于消息的中断（MSI）

**消息信号中断（MSI）** 是一种通过 **内存操作** 而非物理中断线路来触发中断的机制。设备通过写入特定的内存地址，向中断控制器发送中断请求。中断控制器通过检测该内存地址的写入操作，发出中断信号。这种方式不依赖物理线路，而是利用了内存访问机制来传递中断。

3）软件中断

软件中断是由程序通过执行特定指令（如 `ECALL` 或 `EBREAK`）触发的，它并不像硬件中断那样依赖物理中断线路。但是，即使是软件中断，很多现代的架构（包括 RISC-V）也会通过中断控制器来管理这些请求。

### 工作原理
