ChieslAIA的实现遵循了**RISC-V高级中断架构**，实现与规范之间的差异都视为实现BUG

# RISC-V高级中断架构

RISC-V高级中断架构建立在**RISC ISA（RISC指令集）的中断处理功能**的基础上，增加了对以下方面的支持：

1、来自设备的信息信号中断（MSI）

2、在虚拟监管模式（VS模式）下运行的客户操作系统可直接控制设备中断（作为MSI），从而减少对常规管理程序干预的依赖。

3、为RISC-V硬件线程增加了额外的标准本地中断。

4、本地中断和设备中断的优先级可以混用

5、将本地中断有条件地委托给较低特权级别的处理，包括虚拟机



针对上述文字中的疑问进行以下学习

## 1. RISC-ISA 中断处理功能

![image-20241108141426516](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20241108141426516.png)

**触发中断** → **保存状态** → **跳转到处理程序** → **处理中断** → **恢复状态** → **返回正常执行**

### 1.1 中断触发

中断由硬件（外部设备和定时器）或软件触发，CPU会在每个指令周期检查是否有中断信号，并且判断是否满足中断条件（**全局中断使能**、**特定类型的中断使能**），在多个中断信号同事时发时，RISC-V会根据优先级处理。

全局中断使能（Machine Interrupt Enable，MIE）**：本质就是一个bit位，当该位被设置为1时才会响应中断，如果MIE被设置为0，即使有中断信号到达CPU，CPU也不会响应，MIE位于mstatus寄存器中，表示**机器模式**下的全局中断使能（**也就是当MIE位被设置为0，即使中断类型使能被设置为1，也无法响应中断，是中断的全局控制**）

ps：机器模式：RISC-V有三种特权级，分别为机器模式（M模式）、超级模式（S模式）、用户模式（U模式） **———— 这里需要细讲，现在暂时打住**

中断类型的使能：对于每种类型都有对应的使能位，例如MEIE（Machine External Interrupt Enable）用来启用外部中断、MTIE启用定时器中断、MSIE启用软件中断，这些使能位位于mie寄存器中，只有对应中断类型被设置为1，该中断才能被执行

### 1.2 保存上下文状态

在运行中断程序之前，还需要保存原状态信息：

保存当前程序计数器PC到mepc（Machine Exception Program Counter）寄存器

**保存特权级**（Machine Previous Privilege, MPP）和**全局中断状态**（就是MIE）到mstatus寄存器中，以便中断返回后恢复

还可能会保存通用寄存器（x1-x31）、浮点寄存器（f0-f31）、控制状态寄存器、地址寄存器、内存管理寄存器、中断嵌套深度等内容

ps：对于保存全局中断状态的说明：是为了防止以下的情况出现1）中断嵌套场景，在发生中断的过程中，是有可能再次触发其他中断的，所以保存MIE可以控制是否允许在处理当前中断的同时响应其他中断，如果不允许，那么MIE变成了0，中断处理结束，恢复之后MIE就变成0了。   2）中断处理过程中，可能直接不允许其他中断的发生，所以会把MIE变成0，进而在退出后MIE还是0，发生错乱。3）在中断处理过程中，保存的MIE可以确保程序运行环境的一致性，防止中断处理函数对系统状态产生意外的干扰。

ps：对于保存特权级的说明：在1.3部分的By the way说明了中断处理时会提权到机器模式，所以这里需要保存特权级以用于恢复提权之前的特权级。



### 1.3 跳转到中断处理程序

确定中断处理入口地址：CPU从**mtvec寄存器**中获取到，有两种获取模式，应用于不同的场景：

ps：MTVec寄存器（Machine Trap Vector）机器陷阱向量是RISC-V指令集架构的概念，在遇到异常、中断、系统调用时会跳转到一个**预定义**的内存地址执行相对应的处理程序

1、直接模式：所有中断共享一个mtvec入口地址，该地址上，通常会编写一个通用的中断向量处理程序，在这个程序中会读取mcause寄存器（以识别中断的具体类型），从而选择、跳转各自的中断处理程序，通常用于简单系统，或者不需要区分中断入口的应用场景

2、向量模式：不同中断类型有不同的入口地址，这些地址基于mtvec基址加上特定偏移量计算得到，也就说，向量模式下mtvec不再指向统一的入口地址，而是提供了一个基地址+偏移量的方式进入不同类型的中断处理，偏移量是通过访问mcause寄存器存储的中断类型编号得到的，比如mtvec的基地址是0x8240，外部中断的类型是3，那么中断处理的地址就是0x8240+3*偏移单位（4/8），向量模式的优势：快速响应、降低开销，常用于实时系统、嵌入式系统

ps：确定中断处理程序并不需要明确“具体哪个程序调用的中断”，只需要知道是什么设备？是定时器？或者别的中断原因，因为每一种中断原因（硬件/软件）对应的中断处理都是已经预设好的程序，无需确定具体是哪个程序调用的中断。

（By the way，如果中断触发自低特权级（比如用户级），CPU会切换到较高特权级（机器级）执行中断处理程序）



关于mcause寄存器：用于记录中断或异常的原因，是机器模式下的一个重要寄存器，Bit 0：异常/中断标志位 0-异常 1-中断  Bits1-31（1-63）：中断的来源（Bit0 = 1）、异常的类型（Bit0 = 0）



### 1.4 处理中断

执行中断程序：**中断服务程序**（Interupt Service Routine， ISR）根据中断类型进行处理，例如：驱动设备程序的执行、内存的读写、任务调度等，也就是中所述的中断处理程序

更新挂起位：并且中断处理程序通常会清理或更新mip寄存器中对应的中断挂起位，已表明该中断已被响应，更新挂起位的作用：在发起中断后，中断会处于挂起状态，在CPU去响应中断时，挂起的中断并不会立刻清除，只有当在ISR更新挂起位之后，挂起的中断才会清除。

ps：mip寄存器（Machine Interrup Panding）机器中断待处理，该寄存器中的每一个位表示一种中断源的挂起状态，如果某硬件/软件触发了一个中断，那么mip寄存器的对应位会被设置为1，那么表示该中断已经被触发，并等待被处理

ps：为什么中断响应后不立刻更新挂起状态？这是因为可能同一时间有多个同类型的中断源发出中断请求，如果立刻更新的话，那么后面排队的同类型的中断源会立刻把mip寄存器对应的中断位变成1，这样就会造成误判，并且需要注意对于同一类型的中断请求，只有0和1，并不会同时存储/排队多个中断请求（这样能够简化硬件实现，避免了复杂的中断排队机制）

ps：中断控制器是计算机硬件组件（Interrupt Controller），负责管理和处理来自硬件和外设的中断请求，具体而言就是接收、优先级排序并控制中断的传递，其并不在CPU中，而前面提到的mip寄存器、MIE位（mstatus寄存器中）、mie寄存器都在CPU中。中断控制器会监控 `MIP` 寄存器中的位，判断是否有中断源发起了请求，同时根据中断优先级、CPU 的中断使能状态等因素，决定是否将中断信号传递给 CPU。此外，复杂的系统中多个设备可能会产生相同的中断请求，为了防止处理资源浪费，需要提供去抖动（debouncing）和合并请求的功能，这样可以确保只有一个有效的中断信号传递给CPU，此外，中断控制器也设置了中断屏蔽和启用（使能），当然mie寄存器和MIE位已经有了这样的功能，但是在中断控制器中可以更加灵活的针对不同的场景不同的外设进行屏蔽、启用调整，**总体来说中断控制器就是对各个中断源的信息做一个汇总、管理、调度、传递**。

ps：一般而言，对于相同类型的中断，执行的ISR是相同的，只有一些特殊情况下ISR可能会有所不同。 **————（现在不做具体了解）**

ps：ISR执行时一直都是机器模式，所以其有权利在执行的过程中对CPU中的mie、mstatus、mepc等寄存器的信息，这是在执行一些复杂ISR时，需要调整返回后的寄存器存储的内容，以返回正确、合适的特权、中断使能等。



到底是谁让MIP对应位变成挂起状态？硬件？还是中断控制器？





### 1.5 恢复上下文状态

从mepc中恢复之前保存的PC值，确保中断返回后继续执行中断发生前的代码，这里会根据中断的需求有所不同，有些PC存储的是下一条指令执行的地址，有些PC存储的是指令开始的地址，用于重试（异常中断）

中断处理结束后恢复mstatus，CPU会恢复mstatus寄存器中原始特权级和全局中断状态，特权级在中断处理时会进行提权，所以这里需要恢复，而全局中断也可能会被改变，所以这里也会需要进行恢复

如果用了其他的通用寄存器、浮点状态等，都需要进行恢复。

ps：1.5的所有恢复操作都是在执行mret指令时进行的，这里只是阐述需要恢复哪些内容。

### 1.6 返回到正常执行流程

6）返回到正常执行流程

CPU执行mret指令（Machine Return），恢复到中断发生前的特权级和状态，并从mepc恢复的地址处**继续执行原程序**



## 信息信号中断（Message Signaled Interrupts，MSI）

MSI是一种利用**信息信号**的**中断触发机制**，主要用于现代计算机系统中，尤其是在**PCIe总线架构**中，MSI不需要专门的硬件信号线路，而是通过系统**内存**中的特定地址写入数据来发出中断请求。

信号：某种事件或状态的变化，包括了物理的电平变化、逻辑事件的触发、特定条件的触发信号，信号本身不带有信息，而是代表系统中发生的某种特定状态变化的信息，大多数信息就是01信号，在总线控制、外设接口等地方会用到三态逻辑（0-低电平 1-高电平 z-高阻抗），这里只简单的提及。

### 中断触发机制

目前有三种机制

1）基于物理中断线路的中断

传统的硬件中断通常通过 **外部设备的物理信号线路** 来触发。例如，设备（如外设、定时器或其他硬件组件）会通过特定的引脚向 CPU 发送中断请求信号。这些信号可能通过中断控制器进行管理。中断控制器检测到中断信号时，会设置相应的中断标志，通知 CPU 进行中断处理。

2）基于消息的中断（MSI）

**消息信号中断（MSI）** 是一种通过 **内存操作** 而非物理中断线路来触发中断的机制。设备通过写入特定的内存地址，向中断控制器发送中断请求。中断控制器通过检测该内存地址的写入操作，发出中断信号。这种方式不依赖物理线路，而是利用了内存访问机制来传递中断。

3）软件中断

软件中断是由程序通过执行特定指令（如 `ECALL` 或 `EBREAK`）触发的，它并不像硬件中断那样依赖物理中断线路。但是，即使是软件中断，很多现代的架构（包括 RISC-V）也会通过中断控制器来管理这些请求。

### 工作原理

外设发出中断请求信号 - > 把信号写入到内存映射I/O（MMIO）区域中 - > 中断控制器通过不断的监听这些地址 - > 识别写入的值来确定中断源，然后进行后续中断操作。

### PCIe总线架构

(Peripheral Component Interconnect Express，PCIe)高速数据传输总线架构，用于连接主板上的各种外设，如图形卡、网卡、存储设备等

https://blog.csdn.net/gostman/article/details/113107471



报文（Packet）：数据在网络上传输的基本单位，包括了传递的数据和控制信息（源地址、目标地址、校验和等），在PCIe中，报文是（Transaction Layer Packet，TLP）PCIe总线上的数据单元，TLP包含了传输请求、响应、数据块，负责传输命令、数据、状态等信息。

PCIe报文有请求报文（**主机**到设备的读写请求）、响应报文（设备回应主机的请求）、通知报文（通知、报错）

主机（Host）：在PCIe结构中，指的是包含CPU、内存和系统逻辑控制的部分，是计算机系统的核心

TLP报文包括以下部分：头部（Header）、负载（Payload）、尾部（Footer）

头部：报文类型、目标地址、命令识别符、错误检查码

负载：承载实际的数据，负载大小可变，取决于数据的大小

尾部：校验、其他验证信息





### 芯片组







## Tilelink总线

### Tilelink-UL

TileLink是RISC-V开放指令集生态系统中的一种总线协议，TileLink-UL（Uncached Lightweight）是Tilelink总线协议的轻量级变体，主要用于简单的无缓存、请求-响应事务。

主要用于连接低性能的外设以减小总线的面积消耗，有两种类型的操作可供**代理**使用，这两种操作都是访存操作：

ps：代理是指参与通信的设备或模块，他们通过TileLink总线执行不同角色的操作，每个代理根据其功能分为主代理（Master Agent）、从代理（Slave Agent），在TL-UL模式下，主代理发起读写请求，从代理负责响应这些请求，代理模式的设计是为了简化通信结构，使TileLink协议可以应用于各种芯片设计，支持不同的通信模式和设备类型。



1、读（Get）操作：从内存中读取数据

2、写（Put）操作：向内存中写入数据，写操作支持在字节粒度上具有**部分写掩码（通路掩码）**

这里的部分写掩码是一种机制，指定某些字节为有效位，仅更新有效位的字节内数据，例如32位宽的写操作中，通路掩码是：1101，数据：0xAABBCCDD，则写入了第一（0xAA）、第二（0xBB）、第四位（0xDD）字节，这样能够优化总数据传输效率，降低硬件资源的消耗。

读写操作都是在**请求/响应事务结构**中完成的，在TL-UL中，每个信息都在一个beat中，不支持“簇发”操作（Burst），适用于低宽带、简单的外围设备通信。

ps：每个信息在一个beat中：信息独立、单次传输、不需延续，在一个单位时间完成，不被拆分。

ps：簇发操作：在多个连续beat内传输一个完整的数据块，通常用于提升宽带。

ps：beat：一个beat往往对应于一个时间周期，数据传输一次，称为一个节拍beat，突发传输需要多个beat进行传输，那么就需要连续时钟周期来完成一个完整的数据传输。



TL-UL定义了访存操作的三种请求和两种响应信息类型，另一个角度：一个读操作，两个写操作。

![image-20241112104832775](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20241112104832775.png)

对于第一行，Get请求是主设备向从设备请求读取数据，其操作编码是4，通过A通道发送请求，其响应类型是AccessAckData

对于第二行，AccessAckData响应的操作编码是1，是Get操作的响应，通过D通道发送响应，除了会携带响应数据，还会携带一些数据

对于第三行，PutFullData请求是主设备请求写入一块完成的数据块到从设备，其操作编码是0，通过A通过发送请求，其响应类型是AccessAck

对于第四行，PutPartialData，同第三行，表示主设备请求部分写入数据块

对于第五行，AccessAck，是两个写操作的响应类型

ps：A通道和D通道是什么？A通道实际就是主设备发起请求，D通道有两个功能，返回响应或者发送数据，所以对于TL-UL的写操作的一个beat信息传递，就包含了A通道发起请求，D通道传输数据，D通道返回响应；对于读操作，就包含A通道发起请求，D通道返回数据和响应

ps：编码为什么会有相同的情况？因为决定一条信息并不完全由编码来决定，还会通过信息通道和上下文来解读编码含义。





#### 请求响应事务结构（TL，有簇发操作）

响应信号：是由接收请求的代理（一般为从代理）发送回 发送请求的代理（一般为主代理）的一种信息，用于指示请求的结果，是否成功执行、是否发生错误等

定义响应信号何时发送的规则：

允许响应信息的第一个beat是有效的的要求有两条：1）响应信息的第一个beat可以在请求信息的第一个beat变为有效的同一周期内变为有效   2）在请求信息的第一个节拍之后的任意时间时变为有效（请求通道上的ready信号和valid信号在请求信息的第一个节拍内都是高电平时才可以）

valid信号：发送方是否准备好发送数据（自己的状态）、ready信号：接收方是否准备好接收数据（对方的状态），这两个信号包含在第一个beat数据中

ps：接收方和发送方并不是固定的设备，在不同的通道中，其指代是相反的，例如：CPU发送请求给内存，那么在请求通道中CPU是发送方，内存是接收方，内存接收到信息后，需要反馈结果，所以有接收通道，此时发送方是内存，接收方是CPU



在同一个周期内，请求信息的第一个节拍和响应信息的第一个节拍在同一个周期内有效时，只能有几种情况是合法的。

![image-20241111165944475](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20241111165944475.png)

以下情况是合法的：

请求通道：valid高，ready高

响应通道：valid高，ready高

请求通道：valid高，ready低

响应通道：valid高，ready低



提问：为什么同一个周期内，可以同时发生请求和响应？

时间传递的瞬时性？

响应的意义是为了反应数据传输是否成功？是否出错？数据还没到为什么可以响应？





对于一个簇发响应的第一个节拍之后的节拍也可以在任意长的延迟后出现（在这段延迟时间内，不能有其他信息的节拍插入或交错）



响应信息可以与请求的第一个节拍并行组合地接收，与前进进度的规则相互作用。**前进进度规则**定义了在接收响应的代理如何处理响应信号d_ready d_valid的，例如，当d_ready信号为低电平而d_valid信号为高电平时代理如何处理。



ps：TL中有五个通道，包括了前面的响应和请求通道，以及这里的数据通道。

d_ready和d_valid是数据通道的信号，用于控制响应数据的流动，确保数据传输的完整性和有效性。



请求和响应可能在同一周期到达，主设备可能无法立即处理响应，在主设备的D通道输入端添加寄存器（或称缓冲），以暂存响应数据，这样使得系统遵循前进进度规则，允许从设备尽快响应，提高通信效率。



**这里还需要写更多，目前先打住**



#### 数据流和波形

以下会展示一些TL-UL的get put操作的波形图和信息序列图

信息序列图（Massage Sequence Charts，MSC）是用于展示不同代理之间的信息发送顺序、依赖关系和它们如何在时间轴上进行交互。

其时间流动是从上到下的，即从图的顶部到底部流动



图18是get和put操作的波形图，下面对该图进行解释：

1、clock：时钟信号，图中的两条虚线所夹区域就是一个时钟周期，clock的凸起表示高电平，凹下表示低电平，一个完整的高-低波动，构成一个周期，每个周期中其他信号的变化都与时钟周期同步，也就是，将时钟周期的上升沿和下降沿作为其他信号的触发事件

2、a_ready和a_valid，a_ready表示从设备是否准备好接收信号，a_valid表示主发出信号的信号是否有效，如果是高电平，说明已经准备好/有效

3、a_address，请求的地址字段，表示的是读取或写入数据的目标地址

4、a_opcode，操作码字段，用于指示请求的类型，0-写操作，1-部分写操作，4-读操作

5、a_mask：掩码字段，控制哪些字节被有效操作，比如写操作和读操作，都需要操作全部字节，所以是0xf，部分写操作如果只操作低两字节，那么就是0x3

6、a_data：在写操作时，主设备通过这个字段指定要写入的数据内容

7、d_ready和d_valid：d_valid表示从设备的响应是否有效，d_ready表示主设备是否准备好接收从设备的响应

8、d_opcode：响应操作码，用于指示响应的类型，0-AccessAck，1-AccessAckData

9、d_data：用于从设备在响应中传递数据（提问：这里传递的数据是有可能包括响应状态以及实际数据？根据图18，感觉只有实际数据？）



![image-20241112140219229](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20241112140219229.png)

提问：一个beat的时间和时钟周期真的是一对一吗？不是说一个beat对应于一个操作吗？

提问：重积分符号，重积分符号表示事务的持续时间或数据传输的持续时间？





Read backing memory：在Slave收到了读数据请求，Slave去存储数据的物理存储器或缓存区域拿去所需数据。



![image-20241112141056401](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20241112141056401.png)



Write backing memory：把Master传过来的数据写到存储数据的物理存储器或者缓存中。

![image-20241112141115720](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20241112141115720.png)



这是多级别的主从代理对（多层代理通信结构）

Master代理：主设备是发起请求的设备，是发起数据传输/操作的设备

Hierarchical代理：层级代理是介于主设备和从设备之间的中介层，通常用于处理复杂的多级请求和响应机制，用于转发来自Master的请求或者来自slave的响应进行处理并传递回master，并且有一些多层代理结构中，是可能出现一个层级代理负责多个master和多个slave代理的通信的（层级代理是可以有多层的，也就是可以Master<->Hierarchical1<->Hierarchical2<->Slave）

层级代理的作用：一个复杂系统中，主设备和从设备之间可能会使用不同的协议，或者设备的通信速率、功能、资源不同，因此层级代理的功能除了请求转发、响应转发之外，还有如下功能：1）层级代理内部实现了不同协议之间的转换，使得不同类型的设备之间能够互通2）当多个master同时发起请求，层级代理起到调度和负载均衡，避免设备过载影响系统性能（从代理A负载过重，就调度给从代理B处理） 3）层级代理可以对频繁访问的数据进行缓存，减小对下层设备的请求压力。（当主设备请求数据时，层级代理先检查缓存，若缓存中有对应数据，则直接返回，或者，缓存从设备的响应，如果其他设备发出了相同的请求，那么就直接返回缓存的数据。）

图中的Forward A和Forward D转发的意思，也就是Hierarchical层转发通道A的Get操作

![image-20241112141138896](https://raw.githubusercontent.com/upsetgrass/typora_pic_bed/main/image-20241112141138896.png)



#### 五中报文类型的信号编码







### Tilelink









## AXI总线

### AXI4-Lite





### AXI4






